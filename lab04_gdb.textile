h1. Лабораторная работа №4. Отладчик GDB

h2. Краткие теоретические сведения

h3. Понятие об отладке

Отладка  --  это процесс поиска и исправления ошибок в программе. В общем случае его можно разделить на четыре этапа:

* обнаружение ошибки;
* поиск ее местонахождения;
* определение причины ошибки;
* исправление ошибки.

Мы обнаруживаем ошибку когда программа «зависает» во время работы, или когда в программе случается неустранимый сбой и операционная система принудительно завершает ее работу  (т. н. «падение программы»), или если в процессе работы на экран выдается неверная (не такая, как ожидалось) информация. Некоторые ошибки обнаружить труднее: например, когда отличия от правильного результата не бросаются в глаза, или программа работает хорошо, пока не будет введено какое-то определенное значение (например, 0 или отрицательное число). Иногда только после тщательной проверки можно обнаружить, что результат отличается от ожидаемого в полтора раза, или, что в середине списка имен стоят неправильные инициалы.

Второй этап  --  поиск местонахождения ошибки. Часто он является самым трудным. Лучший способ найти место в программе, где находится ошибка  --  это разбивать программу на части и отлаживать их отдельно друг от друга. Структурное программирование идеально подходит для такой отладки.

Третий этап  --  выяснение причины ошибки. Этот этап зачастую занимает второе место по трудности. После того, как будет определено местонахождение ошибки, обычно проще определить причину неправильной работы программы. Например, если вы определили, что ошибка находится в процедуре с именем PrintNames, вам достаточно просмотреть текст только этой процедуры, а не всей программы. Но даже в этом случае ошибка может оказаться настолько неуловимой, что вам придется поэкспериментировать, чтобы ее найти.

Последний этап  --  исправление ошибки. Вооружившись знанием языка программирования и знанием местонахождения ошибки, вы устраняете ее. После этого вы снова запускаете программу, обнаруживаете следующую ошибку, и все начинается снова. При написании программы последовательность этих этапов повторяется многократно.

h3. Методы отладки

Наиболее часто применяют следующие методы отладки:

* создание точек контроля значений на входе и выходе участка программы (например, вывод промежуточных значений на экран  --  так называемые _диагностические сообщения_);
* использование специальных программ  --  отладчиков.

Отладчики позволяют управлять ходом выполнения программы, контролировать и изменять данные. Это помогает быстрее найти место ошибки в программе и ускорить ее исправление. Наиболее популярные способы работы с отладчиком  --  это использование _точек останова_ и _выполнение программы по шагам_.

Пошаговое выполнение  --  это выполнение программы с остановкой после каждой строчки, чтобы программист мог проверить значения переменных и выполнить другие действия.

Точки останова  --  это специально отмеченные места в программе, в которых программа-отладчик приостанавливает выполнение программы и ждет команд. Наиболее популярные виды точек останова:

* Breakpoint  --  собственно, точка останова. Остановка происходит, когда выполнение доходит до определенной строки, адреса или процедуры/функции.
* Watchpoint  --  точка просмотра. Выполнение программы приостанавливается, если программа обратилась к определенной переменной:  либо считала ее значение, либо изменила его.

Точки останова устанавливаются в отладчике на время сеанса работы с кодом программы  --  т.е. они сохраняются до выхода из программы-отладчика или до смены отлаживаемой программы.

h3. Основные возможности отладчика GDB

GDB (GNU Debugger  --  отладчик проекта GNU) работает на многих UNIX-подобных системах и умеет производить отладку многих языков программирования. GDB предлагает обширные средства для слежения и контроля за выполнением компьютерных программ. Отладчик не содержит собственного графического пользовательского интерфейса и использует стандартный текстовый интерфейс консоли. Однако для GDB существует несколько сторонних графических надстроек, а кроме того некоторые интегрированные среды разработки используют его в качестве базовой подсистемы отладки. В этой работе мы познакомимся с самыми основными возможностями GDB.

Отладчик GDB (как и любой другой отладчик) позволяет увидеть, что происходит «внутри» программы в момент ее выполнения, или что делает программа в момент краха.

GDB может выполнять действия четырех основных видов:

* начать выполнение программы, задав все, что может повлиять на ее поведение;
* остановить программу при указанных условиях;
* исследовать, что случилось, когда программа остановилась;
* изменить программу, так чтобы можно было поэкспериментировать с устранением эффектов одной ошибки и продолжить выявление других.

h4. Запуск отладчика GDB; выполнение программы; выход

Синтаксис команды для запуска отладчика имеет следующий вид:

@gdb [опции] [имя_файла | ID процесса]@

После запуска видим текстовое сообщение  --  т. н. «nice GDB logo». В следующей строке приглашение @(gdb)@ ждет ввода команды.

Ниже приведен список некоторых команд GDB.

Краткую справку о любой команде можно получить, введя

@(gdb) help [имя_команды, можно краткое]@

Если при запуске GDB имя исполняемого файла, который нужно отладить, не было указано (что следовало бы делать), то указать его можно командой @file@:

@(gdb) file <имя исполняемого файла, который подлежит отладке>@

Команда @run@ (сокращенно @r@  --  многие команды GDB имеют краткую форму в виде одной или нескольких букв) запускает отлаживаемую программу под GDB. Если требуется, то после команды можно указать список аргументов программы. Также допускается перенаправление потоков ввода и вывода в другие файлы, например

@(gdb) run > outfile@

Если никаких точек останова не определено, то программа выполняется молча, при этом в начале и в конце выводятся сообщения:

bc. (gdb) run
Starting program: test
Program exited normally.
(gdb)


Если же отладчик встречает точку останова, он выдает ее номер, адрес и дополнительную информацию  --  текущую строку, имя процедуры, и т.п.

Команда @kill@ (@k@) прекращает отладку программы. Следует запрос

@Kill the program being debugged? (y or n) y@

Если в ответ введено @y@ (то есть «да»), отладка программы прекращается. Командой @run@ ее можно начать заново, при этом все точки останова (breakpoints), точки просмотра (watchpoints) и точки отлова (catchpoints) сохраняются.

Выход из отладчика  --  команда @quit@ (@q@):

@(gdb) q@

h4. Дизассемблирование программы

Если есть файл с исходным текстом программы, а в исполняемый файл включена информация о номерах строк исходного кода, программу можно отлаживать, работая в отладчике непосредственно с ее исходным текстом. Чтобы программу можно было отлаживать на уровне строк исходного кода, она должна быть откомпилирована с ключом @-g@.

Однако такая возможность есть не всегда, и в случае необходимости отладчик может дизассемблировать исполняемый код, изображая машинные команды в виде ассемблерных мнемоник.

Cуществуют два режима отображения синтаксиса машинных команд: режим Intel, используемый в т.ч. в NASM, и режим ATT (значительно отличающийся внешне). По умолчанию в дизассемблере GDB принят режим ATT. Переключиться на отображение команд с привычным Intel'овским синтаксисом можно, введя команду

@(gdb) set disassembly-flavor intel@

h4. Точки останова

_Примечание_: Информацию о командах этого раздела можно получить, введя

@help breakpoints@

Установить точку останова можно командой @break@ (кратко @b@). Типичный аргумент этой команды  --  место установки. Его можно задать или как номер строки программы (имеет смысл, если есть исходный файл, а программа компилировалась с информацией об отладке), или как имя метки, или как адрес. Чтобы не было путаницы с номерами, перед адресом ставится «звездочка»:

@(gdb) break *0x4000b5@

В данном случае была установлена точка останова по адресу 4000b5, заданному в шестнадцатиричной системе счисления.

Информацию о всех установленных точках останова можно вывести командой @info@ (кратко @i@). Команда @info@ имеет много возможностей, но в данном случае воспользуемся лишь следующим ее форматом:

@(gdb) info breakpoints@

или, кратко

@(gdb) i b@

!images/l4gdb.jpg!

Если какая-то точка останова не нужна, то ее можно сделать неактивной с помощью команды @disable@:

@disable breakpoint <номер этой точки>@

Обратно, деактивированная точка останова активируется командой @enable@:

@enable breakpoint <номер этой точки>@

Статус точки останова (активна она или нет) легко узнать с помощью той же команды @info@. Если же точка останова не требуется вообще, она может быть удалена:

@(gdb) delete breakpoint [номер точки]@

а короче

@(gdb) d b [номер точки]@

Ввод этой команды без аргумента удалит _все_ точки останова.

h4. Возобновление выполнения, пошаговая отладка

Информацию о командах этого раздела можно получить, введя

@(gdb) help running@

Команда @continue@ (@c@) продолжает выполнение остановленной программы:

@(gdb) с [аргумент]@

Выполнение будет происходить, пока снова не встретится точка останова. В качестве аргумента может использоваться целое число N. Это укажет отладчику проигнорировать (N - 1) точку останова (выполнение остановится на N-ой).

Команда @step@ (@s@) приводит к выполнению программы до тех пор, пока не будет достигнута следующая строка ее кода:

@(gdb) s [аргумент]@

При указании аргумента  --  целого числа N, отладчик выполняет команду @step@ N раз (если не останавливает выполнение из-за точек останова или по иным причинам).

Команда @next@ (@n@) действует почти как @step@, но вызов процедуры считается единой инструкцией:

@(gdb) n [аргумент]@

Аргумент N работает так же, как и для @step@.

Команда @finish@ (@fin@) выполняет программу до момента выхода из текущей процедуры (функции):

@(gdb) fin@

Если функция возвращает значение, то это значение выводится тоже.

Команда @until@ (@u@) производит выполнение программы до тех пор, пока не будет достигнута строка с номером, большим текущего. Команду @until@ удобно применять при отладке циклов. Остановка произойдет также, если программа при выполнении цикла выйдет из текущей процедуры, функции.

Команда @stepi@ (@si@) по своему действию подобна @step@, но выполняется не строка, а ровно одна машинная инструкция:

@(gdb) si [аргумент]@

Аргумент N нужен, если требуется выполнить N инструкций.

Команда @nexti@ (@ni@) аналогична @stepi@, но вызов процедуры трактуется отладчиком как одна инструкция, а не как передача управления на еще один блок ассемблерного кода, который тоже должен быть пройден по шагам:

@(gdb) ni [аргумент]@

_Примечание_: при использовании дизассемблированной программы, скомпилированной без информации для отладки, нет возможности выполнить «одну строку исходного кода» за отсутствием такового. В этом случае используются команды @stepi@ и @nexti@.

h4. Работа с данными программы в GDB

Как уже упоминалось, отладчик может показывать содержимое ячеек памяти, а при необходимости позволяет вручную изменять значения регистров и переменных.

Для исследования содержимого памяти можно использовать команду @x@.

@x адрес@ выдает содержимое ячейки памяти по указанному адресу. Формат, в котором выводятся данные, можно задать после имени команды через косую черту: @x/nfu адрес@. Рассмотрим задание формата подробнее.

* @n@  --  счетчик повторений. Это десятичное целое число, по умолчанию 1. Он определяет, сколько ячеек памяти отобразить (считая в единицах @u@).
* @f@  --  формат отображения. Наиболее употребляемые варианты: @s@ (строка, оканчивающаяся нулем), @i@ (машинная инструкция), @x@ (шестнадцатеричное число (значение по умолчанию). Значение по умолчанию изменяется каждый раз, когда вы используете команду с указанным в ней форматом.
* @u@  --  размер отображаемых ячеек памяти. Наиболее распространены варианты @b@ (байт), @h@ (полуслово, 2 байта), @w@ (машинное слово, 4 байта, принято по умолчанию), @g@ (длинное слово, восемь байт).

Например, @x/3uh 0x54320@  --  запрос на вывод трех полуслов (@h@) памяти в формате беззнаковых десятичных целых (@u@), начиная с адреса 0x54320.

C помощью команды @x@ можно отображать также значения регистров (перед именем регистра обязательно ставится префикс @$@), например, @p/x $ax@.

Если необходимо часто выводить значение какого-либо выражения (чтобы увидеть, как оно меняется), вы можете добавить его в _список автоматического отображения_, чтобы GDB выводил его значение каждый раз при остановке вашей программы. Для этого служит команда @display@, которой можно передавать такой же аргумент, как команде @x@. Чтобы убрать элемент данных с заданным номером из списка отображения, можно использовать команду @delete display номера@.

И наконец, изменить значение для регистра или ячейки памяти можно с помощью команды @set@, задав ей в качестве аргумента имя регистра или адрес. При этом перед именем регистра ставится префикс @$@, а перед адресом нужно указать в фигурных скобках тип данных (размер сохраняемого значения; в качестве типа данных можно использовать типы языка Си):

@set  {char}0x600155='s'@

h2. Элементы программирования

h3. Индексный доступ к данным

Для индексного доступа применяют косвенную адресацию. В этом случае адрес ячейки памяти заносят в регистр и используют его в качестве указателя. Для этих целей можно применять любые регистры. Признаком косвенной адресации являются прямоугольные скобки. Пример использования косвенной адресации:

<pre>
; --- регистровая адресация ---
        mov     eax, esi      ; значение регистра \verb!esi! 
                              ; дублируется в \verb!eax!

                              ; --- косвенная адресация ---
        mov     eax, [esi]    ; слово, расположенное по адресу \verb!esi!,
                              ; дублируется в регистре \verb!eax!
</pre>

h3. Инструкции организации циклов

Для организации циклов существуют специальные инструкции. Для всех них максимальное количество проходов задается в регистре @ecx@. Наиболее простой является инструкция @loop@. Она позволяет организовать безусловный цикл:

bc. mov     ecx, 100        ; количество проходов
        mov     esi, Buf1       ; смещение на первый буфер
        mov     ebx, Buf2       ; на второй
 NextStep:
        mov     al,  BYTE [esi] ; перенос байта из одного
        mov     BYTE [ebx], al  ; буфера в другой
        inc     esi             ; перемещение указателей к
        inc     ebx             ; следующим элементам буфера
        loop    NextStep        ; повторить \verb!ecx! раз от метки \verb!NextStep!      


h2. Задание для выполнения

# Написать программу со следующим алгоритмом:
#* ввести с клавиатуры символьную строку в буфер;
#* изменить порядок следования символов в строке на противоположный; положение символа 10 (@\n@) остается без изменений;
#* вывести результат на экран;
#* завершить программу.
# Загрузить программу в отладчик. Какими способами это можно сделать?
# Просмотреть дизассемблированный код программы, введя команду
@disassemble _start@
# Переключить дизассемблер GDB с синтаксиса АTT на синтаксис Intel и снова выполнить показ дизассемблированного кода. Найти три отличия. Переписать в тетрадь адрес второй инструкции в формате 0x12345678.
# Установить точку останова на второй инструкции, указав её адрес (записан в тетради).
# Выполнить программу. Что произошло?
# Выполнить программу по шагам.
# Посмотреть содержимое регистров в окне и с помощью команды @info r@.
# Выполнить программу до места заполнения входного буфера. Вывести содержимое входного буфера в в шестнадцатеричном формате и в символьном виде (команда @x@ ).
# Выполнить 2 прохода цикла по шагам, контролируя значения регистров. Какие регистры изменяются в цикле?
# Изменить число проходов цикла на 5.
# Изменить содержимое выходного буфера. Вводить данные как символы и как десятичные числа.
