h1. Лабораторная работа №. Первая программа на языке ассемблера

h2. Краткие теоретические сведения

h3. Структура ассемблерной программы

[sec:11]

Каждый язык программирования имеет свои особенности. Язык ассемблера - не исключение, особенно, если программировать на нем на платформе Linux. Рассмотрим пример простой программы на этом языке под эту платформу. Традиционно первая программа выводит приветственное сообщение на экран.

<pre>
SECTION .data
    hello:     DB 'Hello world!',10 ; 'Hello world!' плюс символ
                              ; возврата каретки
    helloLen:  EQU $-hello        ; Длина строки 'Hello world!'

SECTION .text           ; Начало секции кода
    GLOBAL _start       ; Метка \verb!_start! должна быть глобальной, 
                    ; чтобы линкер смог её найти и сделать 
                    ; точкой входа в программу.
_start:
    mov eax,4           ; Системный вызов для записи (\verb!sys_write!)
    mov ebx,1           ; Описатель файла $1$ - стандартный вывод
    mov ecx,hello       ; Адрес строки \verb!hello! в \verb!ecx!
    mov edx,helloLen    ; \verb!helloLen! - константа, а не переменная, 
                    ; потому нет необходимости использовать 
                    ; \verb!mov edx,[helloLen]! для получения 
                    ; действительного значения

    int 80h         ; Вызов ядра

    mov eax,1           ; Системный вызов для выхода (\verb!sys_exit!)
    mov ebx,0           ; Выход с кодом возврата $0$ (без ошибок)
    int 80h         ; Вызов ядра
</pre>

В отличие от многих современных высокоуровневых языков программирования, в ассемблерной программе каждая команда располагается на _отдельной строке_. Нельзя разместить несколько команд на одной строке. Не принято также разбивать одну команду на несколько строк.

Синтаксис ассемблера NASM является _регистрочувствительным_. Т.е. есть разница между большими и малыми буквами.

Команда может быть _директивой_ &quot; --  указанием транслятору, которое выполняется в процессе превращения программы в машинный код. Многие директивы начинаются с точки. Для удобства чтения программы они обычно пишутся БОЛЬШИМИ БУКВАМИ. Кроме директив еще бывают _инструкции_ &quot; --  команды процессору. Именно они и будут составлять машинный код программы.

Нужно отметить, что понятие &lt;&lt;машинного кода&gt;&gt; очень условно. Часто оно обозначает просто содержимое выполняемого файла, хранящего кроме собственно машинных команд еще и данные (в нашем случае &quot; --  текст выводимого сообщения &lt;&lt;Hello world&gt;&gt;).

h3. Особенности создания ассемблерной программы

На платформе Linux язык ассемблера является самым низкоуровневым языком программирования. Т.е. он больше любых других приближен к архитектуре ЭВМ и ее аппаратным возможностям, позволяет получить к ним более полный доступ, нежели в языках выского уровня, наподобие C/C++, Perl, Python и пр. Заметим, что получить полный доступ к ресурсам компьютера в современных архитектурах нельзя, самым низким уровнем работы программы является обращение напрямую к ядру ОС. Именно на этом уровне и работают программы, написанные на ассемблере в Linux. Но, в отличие от языков высокого уровня (ЯВУ), ассемблерная программа содержит только тот код, который _ввел программист_, и конечно же вся ответственность за логичность кода _полностью_ лежит на плечах _программиста_.

Простой пример. Обычно подпрограммы заканчиваются командой возврата. Если в ЯВУ ее не задать явно, транслятор все равно добавит ее в конец подпрограммы. Ассемблерная подпрограмма без команды возврата _не вернется_ в точку вызова, а будет выполнять код, следующий за подпрограммой, как будто он является ее продолжением.

Еще пример. Можно попробовать &lt;&lt;выполнить&gt;&gt; данные вместо кода. Часто это лишено смысла. Но если программист это сделает, транслятор не выдаст никаких сообщений об ошибке. Язык ассемблера позволяет делать все! Вопрос состоит лишь в том, какие усилия придется приложить, чтобы реализовать идею на этом языке. Тут меньше ограничений, чем в ЯВУ, но, в то же время, и удобства и простоты создания программ тоже меньше.

Эти особенности приводят к тому, что ассемблерные программы часто &lt;&lt;подвешивают&gt;&gt; компьютер, особенно у начинающих программистов. Выделим разновидности &lt;&lt;зависания&gt;&gt; по способу борьбы с ним.

* Простое &quot; --  для выхода из него достаточно нажать Ctrl+C (сначала нажимается клавиша Ctrl, и дальше нужно, _не отпуская_ ее, нажать вторую клавишу &quot; --  C; затем клавиши отпускаются в любом порядке). Программа при этом аварийно завершается выходом в ОС.
* Мягкое &quot; --  кажется, что машина никак не реагирует на клавиатуру и безнадежно зависла. В любом случае, ядро системы при этом продолжает работать и позволяет использовать базовые функции для сохранения целостности данных. Этими функциями можно управлять при помощи т. н. Magic Keys (см. описание SysRq Keys).
* Жесткое &quot; --  если зависло ядро ОС. Это может случиться в случае использования тестового ядра, находящегося в разработке, или при неправильной ручной сборке ядра, или при попытке использовать недокументированные особенности аппаратного обеспечения. В этом случае поможет аппаратный сброс при помощи кнопки &lt;&lt;Reset&gt;&gt;, расположенной на передней панели системного блока.

Важно помнить, что в 90% случаев зависание является простым. Чаще всего не хватает аппаратных возможностей компьютера для быстрой обработки данных и необходимо просто подождать или нажать Ctrl+C.

h3. Процесс обработки программы на языке ассемблера

Из-за специфики программирования, а также по традиции, для создания программ на языке ассемблера обычно пользуются утилитами командной строки (хотя поддержка ассемблера и есть в некоторых универсальных интегрированных средах). Весь процесс технического создания ассемблерной программы можно разбить на 4 шага (исключены этапы создания алгоритма, выбора структур данных и т.д.).

# Набор программы в текстовом редакторе и сохранение ее в отдельном файле. Каждый файл имеет имя и тип, называемый иногда расширением. Тип в основном используется для определения назначения файла. Например, программа на C имеет тип @c@, на Pascal &quot; --  @pas@, на языке ассемблера &quot; --  @asm@.
# Обработка текста программы транслятором. На этом этапе текст превращается в машинный код, называемый объектным. Кроме того есть возможность получить листинг программы, содержащий кроме текста программы различную дополнительную информацию и таблицы, созданные транслятором. Тип объектного файла &quot; --  @o@, файла листинга &quot; --  @lst@. Этот этап называется _трансляцией_.
# Обработка полученного объектного кода компоновщиком. Тут программа &lt;&lt;привязывается&gt;&gt; к конкретным условиям выполнения на ЭВМ. Полученный машинный код называется выполняемым. Кроме того, обычно получается карта загрузки программы в ОЗУ. Выполняемый файл обычно не имеет расширения в отличие от программ ОС семейства DOS и Windows, карта загрузки &quot; --  @map@. Этот этап называется _компоновкой_ или _линковкой_.
# Запуск программы. Если программа работает не совсем корректно, перед этим может присутствовать этап _отладки_ программы при помощи специальной программы &quot; --  отладчика. При нахождении ошибки приходится проводить коррекцию программы, возвращаясь к шагу 1.

Таким образом, процесс создания ассемблерной программы можно изобразить в виде следующей схемы. Конечной целью, напомним, является работоспособный выполняемый файл @hello@ (см. рис. [pic:l1]).

[ht] [pic:l1]

h3. Основные возможности текстового редактора mcedit

@mcedit@ &quot; --  это текстовый редактор, встроенный в двухпанельный файловый менеджер Midnight Commander. Сама по себе среда Midnight Commander (или просто @mc@) очень схожа с другими &lt;&lt;командерами&gt;&gt;. Например, чтобы создать в текущем каталоге файл @lab1.asm@ и начать его редактирование, можно набрать:

@mcedit ./lab1.asm@

Общий вид командной строки для запуска:

@mcedit [-bcCdfhstVx?] [+число] file@

Некоторые параметры:

lp12cm

+число &amp; переход к указанной числом строке (не ставьте пробел между знаком + и числом)
-b &amp; черно-белая цветовая гамма
-c &amp; цветовой режим ANSI для терминалов без поддержки цвета
-d &amp; отключить поддержку мыши
-V &amp; вывести версию программы


@mcedit@ &quot; --  это полноценный полноэкранный редактор, позволяющий редактировать файлы размером до 64 Мб, с возможностью редактирования бинарных файлов. Основными возможностями являются: копирование блока, перемещение, удаление, вырезка, вставка; отмена; выпадающие меню; вставка файлов; макро-команды; поиск регулярных выражений и их замена; подсветка синтаксиса; перенос по словам; изменяемая длина табуляции; использование перенаправления потоков для применения, например, проверки орфографии при помощи ispell.

Редактор крайне прост в использовании и может быть использован без предварительного изучения. Выпадающее меню вызывается клавишей F9. Список наиболее часто используемых горячих клавиш приведен ниже (Ctrl и Shift обозначают соответствующие клавиши клавиатуры, Meta &quot; --  условное обозначение для набора мета-клавиш, на современном компьютере это обычно Alt или Esc):

lp11cm

F3 &amp; Начать выделение текста. Повторное нажатие F3 закончит выделение
Shift+F3 &amp; Начать выделение блока текста. Повторное нажатие F3 закончит выделение
F5 &amp; Скопировать выделенный текст
F6 &amp; Переместить выделенный текст
F8 &amp; Удалить выделенный текст
Meta+l &amp; Переход к строке по её номеру
Meta+q &amp; Вставка литерала (непечатного символа). См. ниже
Meta+t &amp; Сортировка строк выделенного текста
Meta+u &amp; Выполнить внешнюю команду и вставить в позицию под курсором её вывод
Ctrl+f &amp; Занести выделенный фрагмент во внутренний буфер обмена @mc@ (записать во внешний файл)
Ctrl+k &amp; Удалить часть строки до конца строки
Ctrl+n &amp; Создать новый файл
Ctrl+s &amp; Включить или выключить подсветку синтаксиса
Ctrl+t &amp; Выбрать кодировку текста
Ctrl+u &amp; Отменить действия
Ctrl+x &amp; Перейти в конец следующего слова
Ctrl+y &amp; Удалить строку
Ctrl+z &amp; Перейти на начало предыдущего слова
Shift+F5 &amp; Вставка текста из внутреннего буфера обмена @mc@ (прочитать внешний файл)
Meta+Enter &amp; Диалог перехода к определению функции
Meta+- &amp; Возврат после перехода к определению функции
Meta++ &amp; Переход вперед к определению функции
Meta+n &amp; Включение/отключение отображения номеров строк
tab &amp; Отодвигает вправо выделенный текст, если выключена опция &lt;&lt;Постоянные блоки&gt;&gt;
Meta-tab &amp; Отодвигает влево выделенный текст, если выключена опция &lt;&lt;Постоянные блоки&gt;&gt;
Shift+Стрелки &amp; Выделение текста
Meta+Стрелки &amp; Выделение вертикального блока
Meta+Shift+- &amp; Переключение режима отображения табуляций и пробелов
Meta+Shift++ &amp; Переключение режима &lt;&lt;Автовыравнивание возвратом каретки&gt;&gt;


Также работают и привычные по Norton и Volcov Commander'ам клавиши:

lp12cm

Ctrl-Ins &amp; копировать
Shift-Ins &amp; вставить
Shift-Del &amp; вырезать
Ctrl-Del &amp; удалить выделенный текст.


Выделение мышью также работает на некоторых терминалах.

Клавиши автозавершения (обычно Alt-Tab или Escape Tab) завершают слово, на котором находится курсор, используя ранее применявшиеся в файле слова.

Для задания макроса нажмите Ctrl-R и нажимайте клавиши, которые нужны для воспроизведения в будущем. Повторное нажатие Ctrl-R завершит запись макроса. Затем нажмите на клавишу, на которую хотите повесить этот макрос. Макрос сохранится, когда нажмете Ctrl-A и затем назначенную макросу клавишу. Макрос выполнится по нажатию Meta, Ctrl, или Esc назначенной клавиши, если клавиша не используется другими функциями.

Дополнительную информацию, как обычно в Linux, можно получить при помощи команды @man mc@.

h3. Правила оформления ассемблерных программ

При наборе программ на языке ассемблера придерживайтесь следующих правил:

* директивы набирайте большими буквами, инструкции - малыми;
* пишите текст широко;
* не выходите за край экрана - его неудобно будет редактировать и печатать;
* для отступов пользуйтесь табуляцией (клавиша TAB);
* блоки комментариев задавайте с одинаковым отступом.

Оптимальной считается такая строка:

@<TAB><TAB>mov<TAB>eax,<пробел>ebx<(1-3)TAB>;<пробел>текст комментария@

Количество табуляций перед комментарием определяется длиной аргументов команды и может быть от 1 до 3.

По мере знакомства с синтаксисом языка будут приводиться дополнительные правила.

h3. Транслятор NASM

NASM превращает текст программы в объектный код. Имя программы задается в командной строке. В простейшем случае это выглядит так: @nasm hello.asm@ (расширение указывать обязательно). Текст программы из файла @hello.asm@ преобразуется в объектный код, который запишется в файл @hello.o@. Т. о. имена всех файлов получаются из имени входного файла и расширения по умолчанию.

NASM всегда создает выходные файлы в _текущем_ каталоге.

NASM не запускают без параметров, т. к. он &quot; --  всего лишь транслятор, а не интегрированная среда разработки.

Рекомендуется в рабочем каталоге все файлы хранить в определенной иерархии. Например, для первой работы создайте каталог @~/labs/asm/01@.

Для запуска транслятора достаточно набрать @nasm hello.asm@. При этом вы не увидите никаких сообщений &quot; --  они появляются только в случае ошибок или предупреждений. При наличии ошибок объектный файл не создается.

Например, для компиляции приведенного выше текста программы &lt;&lt;Hello World&gt;&gt; необходимо писать:

@nasm -f elf hello.asm@

Ключ -f указывает транслятору создавать бинарные файлы в формате ELF (если используется 64-битная версия Linux, следует вместо elf указывать elf64 для генерации 64-битного кода).

Более подробно синтаксис командной строки рассмотрен в следующих работах.

h3. Компоновщик LD

Как видно из схемы на рис. [pic:l1], чтобы получить исполняемую программу, объектный файл необходимо передать на обработку компоновщику (или, как его еще называют, линковщику):

@ld -o hello hello.o@

Ключ -o с последующим значением задает в данном случае имя создаваемого исполняемого файла.

Формат командной строки LD подробно рассмотрен в следующих работах, также его можно увидеть, набрав @ld --help@. Для получения более подробной информации см. @man ld@. Запустить на выполнение созданный исполняемый файл можно, набрав в командной строке:

@./hello@

Примечание: в данном случае исполняемый файл hello выполняется из текущего каталога (что обеспечивают символы &lt;&lt;./&gt;&gt; перед его именем).

h2. Порядок выполнения работы

# Создайте в своем домашнем каталоге новый подкаталог с именем @asm_01@. Создайте в нем с помощью редактора mcedit текстовый файл @lab1.asm@, и введите в него текст программы из п. [sec:11], пользуясь правилами оформления ассемблерных программ.
# Оттранслируйте полученный текст программы в объектный файл.
# Выполните линковку объектного файла и запустите получившийся исполняемый файл.
# Измените в тексте программы выводимую на экран строку с Hello world! на свою фамилию. Повторите пункты 2 и 3.

h2. Контрольные вопросы

# Как обрабатываются блоки текста в редакторе @mcedit@?
# Как восстановить в @mcedit@ удаленные строки?
# Какие основные отличия ассемблерных программ от ЯВУ?
# В чем отличие инструкции от директивы?
# Каковы правила оформления программ на языке ассемблера?
# Каковы этапы получения выполняемого файла?
# Каково назначение этапа трансляции?
# Каково назначение этапа компоновки?
# Какие файлы могут создаваться при трансляции программы, какие из них создаются по-умолчанию?
# Каковы форматы файлов для @nasm@ и @ld@?
