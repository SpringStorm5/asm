h1. Лабораторная работа №2. Дополнительные приемы трансляции программы на языке ассемблера

h2. Краткие теоретические сведения

h3. Системные инструменты

h4. Расширенный синтаксис командной строки NASM и LD

Полный вариант командной строки nasm выглядит следующим образом:

<tt> nasm [-@ косвенный_файл_настроек] [-o объектный_файл] 
</tt>
<tt> [-f формат_объектного_файла] [-l листинг] [параметры...] [--] исходный_файл </tt>

Для более подробной информации см. @man nasm@. Для получения списка форматов объектного файла см. @nasm -hf@.

Пример @nasm -f elf64 -g -l main.lst main.asm@ скомпилирует исходный файл @main.asm@ в @main.o@, при это формат выходного файла будет @elf64@, и в него будут включены символы для отладки (@g@), вдобавок будет создан файл листинга @main.lst@.

_Примечание_: формат @elf64@ позволяет создавать исполняемый код, работающий под 64-битными версиями Linux. Для 32-битных версий ОС указываем в качестве формата просто @elf@.

Компоновщик @ld@ имеет следующий формат командной строки:

<tt>ld [параметры] объектные_файлы...<\tt>

Для более подробной информации см. @ld --help@ или @man ld@.

Пример @ld -Map main.map -o main main.o@ создаст исполняемый файл @main@ из объектного файла @main.o@, при этом создавая карту памяти в файл @main.map@.

Компоновщик @ld@ не предполагает по умолчанию расширений для файлов. Но принято использовать следующие расширения:

* @o@ для объектных файлов;
* _без расширения_ для исполняемых файлов;
* @map@ для файлов схемы программы;
* @lib@ для библиотек.

Если имя выполняемого файла не определено, оно будет образовано из имени первого объектного файла.

h4. Утилита MAKE

@make@ - утилита GNU для обработки групп программ. В том числе она может управлять трансляцией и компоновкой. Поведение @make@ описывается файлом @Makefile@, который должен присутствовать в текущем каталоге. Это текстовый файл, который может содержать:

* комментарии;
* правила;
* макроопределения.

Пример:

bc. build:
    nasm -f elf64 -g -l main.lst main.asm
    ld -Map main.map -o main main.o
clean:
    rm -f main main.o main.lst main.map
# здесь могут быть дополнительные команды


В примере созданы два правила с именами («целями») @build@ и @clean@. Первое из них выполняет трансляцию и сборку программы @main.asm@, а второе удаляет все созданные предыдущим правилом файлы. Таким образом, если набрать в командной строке @make build@, то будет создан исполняемый файл из @main.asm@. Если набрать @make clean@, то проект будет очищен: будут удалены все файлы, создаваемые @nasm@ и @ld@. Для более подробной информации см. @man make@.

_Примечание_: утилита make необычно требовательна к содержимому make-файла. Ей необходимо, чтобы команды в правилах (в отличие от целей) начинались с отступа, и отступ обязательно должен создаваться символом табуляции, а не пробелами. Редактор @mcedit@ по умолчанию заменяет табуляции пробелами. Чтобы он создавал настоящую табуляцию, нужно в меню (F9) выбрать подпункт «Общая» пункта «Настройка» и убрать галочку в пункте «Симулировать неполную табуляцию».

h4. Основы работы с Midnight Commander

Midnight Commander (или просто @mc@) -- это программа, которая позволяет просмотреть структуру каталогов и выполнить основные операции по управлению файловой системой. Другими словами, это файловый менеджер. Если вы имеете опыт работы с другими подобными файловыми менеджерами, например Norton Commander (@nc@) в DOS или FAR в Windows, то вы легко сможете работать и с @mc@, поскольку основные особенности поведения и даже основные комбинации «горячих клавиш» у них совпадают.

Для активации оболочки MC достаточно ввести в командной строке @mc@ и нажать клавишу ввод.

Хотя для управления файловой системой и вообще для работы с файлами можно использовать такие команды операционной системы, как @pwd@, @ls@, @cd@, @mv@, @mkdir@, @rmdir@, @cp@, @rm@, @cat@, @more@ и т. д., многие операции с файлами удобнее делать с помощью программы Midnight Commander, которая наглядно представляет все выполняемые действия.

Наиболее часто выполняемые в Midnight Commander операции привязаны к функциональным клавишам &lt;F1&gt;  -  &lt;F10&gt;. Приведем сводку в виде таблицы.


|*Функциональная клавиша* | *Выполняемое действие*|
|&lt;F1&gt; | Вызывает контекстно-зависимую подсказку|
|&lt;F2&gt; | Вызывает меню, создаваемое пользователем|
|&lt;F3&gt; | Просмотр файла, на который указывает подсветка в активной панели|
|&lt;F4&gt; | Вызов встроенного редактора для файла, на который указывает подсветка в активной панели|
|&lt;F5&gt; | Копирование файла или группы отмеченных файлов из каталога, отображаемого в активной панели, в каталог, отображаемый на второй панели. При копировании одного файла можно поменять его имя. Можно также указать имя каталога, куда будет производиться копирование (если надо скопировать в каталог, отличный от каталога, отображаемого во второй панели)|
|&lt;F6&gt; | Перенос файла или группы отмеченных файлов из каталога, отображаемого в активной панели, в каталог, отображаемый на второй панели. Как и при копировании, можно поменять имя файла или целевого каталога.|
|&lt;F7&gt; | Создание подкаталога в каталоге, отображаемом в активной панели|
|&lt;F8&gt; | Удаление файла (подкаталога) или группы отмеченных файлов|
|&lt;F9&gt; | Вызов основного меню программы (отображаемого над панелями)|
|&lt;F10&gt; | Выход из программы|


Вызвать главное меню можно клавишей F9.

Выпадающее подменю «Команды» главного меню позволяет выполнить еще ряд операций по управлению файловой системой, а также выполнить некоторые команды, изменяющие вид панелей Midnight Commander и отображаемую в панели информацию.

При обращении к команде меню «Дерево каталогов» выводится окно, отображающее структуру каталогов файловой системы.

Команда «Поиск файла» (горячие клавиши &lt;Meta&gt;+&lt;?&gt; или &lt;Esc&gt;,&lt;?&gt;) выпадающего меню «Команда» позволяет вам найти на диске файл с заданным именем. После выбора этой команды меню вначале запрашивается имя искомого файла и имя каталога, с которого необходимо начинать поиск. Нажав экранную кнопку «Дерево», вы можете выбрать начальный каталог поиска из дерева каталогов. В поле «Содержание» (Contents) можно задать регулярное выражение по правилам команды @egrep@. В частности, это означает, что перед символами, имеющими специальное значение для @egrep@, необходимо вставить символ «<tt>\<\tt>», например, если вам нужно найти строку «strcmp (», вы должны указать шаблон поиска в виде «<tt>strcmp \(<\tt>». Для того, чтобы начать поиск, нажмите экранную кнопку «Дальше». Во время поиска его можно приостановить кнопкой «Остановить» и продолжить по кнопке «Продолжить».

Список найденных файлов можно просматривать, перемещаясь с помощью клавиш &lt;Стрелка вверх&gt; и &lt;Стрелка вниз&gt;. Кнопка «Перейти» используется для перехода в каталог, в котором находится подсвеченный файл. Кнопка «Повтор» служит для задания параметров нового поиска.

Кнопка «Выход» служит для выхода из режима поиска.

Нажатие на кнопку «Панелизация» приведет к тому, что результаты поиска будут отображены на текущую активную панель, так что вы можете производить с выбранными файлами еще какие-то действия (просматривать, копировать, перемещать, удалять и так далее). После вывода на панель можно нажать &lt;Ctrl&gt;+&lt;R&gt; для возврата к обычному списку файлов.

Команда «Переставить панели» (&lt;Ctrl&gt;+&lt;U&gt;) меняет местами содержимое правой и левой панелей.

По команде «Отключить панели» (&lt;Ctrl&gt;+&lt;O&gt;) показывается вывод последней из выполнявшихся команд shell.

По команде «Сравнить каталоги» (&lt;Ctrl-X&gt;, &lt;D&gt;) сравнивается содержимое каталогов, отображаемых на левой и правой панелях.

Команда меню «История команд» выводит окно со списком ранее выполнявшихся команд. Подсвеченную строку из истории можно скопировать в командную строку оболочки (перемещение подсветки --  клавишами &lt;Стрелка вверх&gt; и &lt;Стрелка вниз&gt;, копирование --  по клавише &lt;Enter&gt;).

Команда меню «Фоновые задания» позволяет вам управлять фоновыми заданиями, запущенными из Midnight Commander (такими заданиями могут быть только операции копирования и перемещения файлов). Используя эту команду меню или горячие клавиши &lt;Ctrl&gt;+&lt;X&gt;, &lt;J&gt;, вы можете остановить, возобновить или снять любое из фоновых заданий.

После выбора команды меню «Файл расширений» вы получаете возможность редактировать файл @mc.ext@, в котором можете связать с определенным расширением файла (окончанием имени после последней точки) программу, которая будет запускаться для обработки (просмотра, редактирования или выполнения) файла с таким расширением. Запуск выбранной программы будет осуществляться после установки подсветки на имя файла и нажатия клавиши &lt;Enter&gt;.

Команда «Файл меню» используется для редактирования пользовательского меню (которое появляется после нажатия клавиши &lt;F2&gt;).

h4. Настройка оболочки Midnight Commander

Одно из важных достоинств @mc@ --  конфигурируемость. Поскольку получение выполняемого файла из ассемблерной программы выполняется ручным запуском нескольких программ, на практике этот процесс как правило автоматизируют, например с использованием утилиты @make@. Но конечно же есть и другие способы. Несколько вариантов возможной автоматизации предоставляет @mc@.

Первый способ --  это использование упоминавшегося выше файла расширений. За каждым _типом_ файла можно закрепить действия, которые будут выполняться при выборе нужного файла и нажатии на клавишу &lt;Enter&gt;. Это действие задается в специальном файле расширений (bindings) @mc.ext@ (F9<span class="math">\rightarrow</math>Команда<span class="math">\rightarrow</math>Файл расширений). Он имеет текстовый формат и может быть отредактирован любым текстовым редактором. Но предпочтение лучше отдавать встроенному редактору @mc@, т. к. в этом случае на экран появится подсказка по внутреннему формату файла. Наиболее просто войти в режим редактирования через меню @mc@, выбрав F9<span class="math">\rightarrow</math>Команда<span class="math">\rightarrow</math>Файл расширений.

Второй способ --  использование меню. В отличие от предыдущего варианта, тут можно выбрать различные действия для одного и того же файла. Например, можно просто получить выполняемый модуль, а можно получить и запустить его. Настройка меню хранится в текстовом файле @.mc.menu@ или @.mc/menu@. Как и файлов расширений, файлов меню может быть много, они бывают основными и локальными. Для их настройки можно выбрать: F9 <span class="math">\rightarrow</math> Команда <span class="math">\rightarrow</math> Файл меню <span class="math">\rightarrow</math> Main/Local. Внутренний формат очень похож на формат файла расширения и тоже ясен из подсказки.

h3. Элементы программирования

h4. Описание инструкций MOV и INT

Инструкция языка ассемблера mov предназначена для дублирования данных источника в приемнике. В общем виде записывается

@mov dst, src@

где @dst@ -- приемник, @src@ -- источник.

Инструкция языка ассемблера @int@ предназначена для вызова прерывания с указанным номером. В общем виде записывается

@int n@

где @n@ --  номер прерывания, принадлежащий диапазону 0 - 255. При программировании в Linux с использованием вызовов ядра (sys&#95;calls) @n = 80h@ (принято задавать в шестнадцатеричной системе счисления).

Вызывая инструкцию @int 80h@, мы выполняем системный вызов какой-либо функции ядра Linux. При этом происходит передача управления ядру операционной системы. Чтобы узнать, какую именно системную функцию нужно выполнить, ядро извлекает номер системного вызова из регистра @eax@. Поэтому перед вызовом прерывания необходимо поместить в этот регистр нужный номер --  например, выполнить @mov eax, 3@ для системного вызова номер 3. Многим системным функциям требуется передавать какие-либо параметры. По принятым в ОС Linux правилам, эти параметры помещаются в порядке следования в остальные регистры процессора: @ebx@, @ecx@, @edx@ и т. д. Если системная функция должна вернуть значение, она помещает его в регистр @eax@.

h4. Системные вызовы для обеспечения диалога с пользователем

Простейший диалог с пользователем требует наличия двух функций: вывода текста на экран и ввода текста с клавиатуры. Простейший способ вывести строку на экран --  использовать системный вызов @write@, который аналогичен функции @write@ из языка Си и предназначен для записи данных в файл. Этот системный вызов имеет номер 4, поэтому перед вызовом инструкции @int@ необходимо поместить значение 4 в регистр @eax@. Первым аргументом @write@, помещаемым в регистр @ebx@, задается дескриптор файла. Для вывода на экран в качестве дескриптора файла нужно указать 1 (что означает «стандартный вывод», т. е. вывод на дисплей).

Вторым аргументом задается адрес выводимой строки (помещаем его в регистр @ecx@, например инструкцией @mov ecx, hello@). Строка может иметь любую длину. Последним аргументом (т.е. в регистре @edx@) должна задаваться максимальная длина выводимой строки (посмотрите, как это делалось в программе из предыдущей работы).

Для ввода строки с клавиатуры можно использовать аналогичный системный вызов @read@. Этот системный вызов имеет номер 3. Подробная информация о нем, предоставляемая командой @man 2 read@ показывает, что его аргументы -- такие же, как у вызова @write@, только для «чтения» из клавиатуры мы используем файловый дескриптор 0 (стандартный ввод) а не (1 -- стандартный вывод -- как было при выводе на дисплей). Возвращаемое через регистр @eax@ значение функции @read@ -- количество прочитанных с клавиатуры символов.

h2. Порядок выполнения работы

# Создайте новый текстовый файл @asdfg.asm@ и сохраните его в своем домашнем каталоге.
# Пользуясь информацией п. [sec:l2] написать программу, работающую по следующему алгоритму:
#* вывести приглашение, типа &quot;Введите строку:&quot;;
#* ввести строку с клавиатуры;
#* вывести введенную строку на экран.
# Создайте в своем домашнем каталоге новый подкаталог и скопируйте в него созданный файл с текстом программы.
# Скопируйте файл @asdfg.asm@ в @lab02-1.asm@.
# Оттранслируйте полученный текст программы в объектный файл по схеме @lab02-1.asm@ <span class="math">\rightarrow</math> @q.o@ и @asdfg.asm@ <span class="math">\rightarrow</math> @w.o@.
# Повторить результат предыдущего пункта с использованием косвенного файла.
# Создать для MAKE файл с явными правилами получения выполняемых файлов двух написанных программ. Проверить работу MAKE, внося изменения в комментарии программы.
# Настроить файл расширений так, чтобы для @asm@ выполнялась трансляция, а для @obj@ --  компоновка c созданиeм файла карты загрузки.
# Создать локальное меню для @mc@, в котором для клавиши F5 задать запуск полного процесса получения выполняемого файла из программы, на которую установлен курсор.

h2. Контрольные вопросы

# Каково назначение и формат косвенных командных файлов для NASM?
# Каково назначение и формат файлов подсказки для LD?.
# Каково назначение утилиты MAKE?
# Где задаются правила поведения MAKE?
